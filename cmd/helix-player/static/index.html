<!DOCTYPE html>
<html lang='en'>
<head>
	<meta charset='utf-8'>
	<title>Helix Player</title>
	<style>
input[type=checkbox] ~ ul {
        visibility: hidden;
}
input[type=checkbox]:checked ~ ul {
        visibility: visible;
}
	</style>
</head>

<body>
	<main>
		<div id='player'>
			<audio autoplay controls></audio>
			<video autoplay controls></video>
			<ul>
			</ul>
		</div>
	</main>

	<script type='module'>
		import { elemRegister } from './elems.js';

		elemRegister( '_', null, 'audio', 'button', 'input', 'label', 'li', 's', 'ul', 'video' );

		class API {
			async directories() {
				const rsp = await fetch( '/directories/', {
					headers: {
						Accept: 'application/json',
					}
				} );
				return rsp.json()
			}

			async object( directory, id ) {
				const rsp = await fetch( `/directories/${directory}/${id}`, {
					headers: {
						Accept: 'application/json',
					}
				} );
				return rsp.json()
			}

			async objectBlob( directory, id, mimetype ) {
				const rsp = await fetch(
					`/directories/${directory}/${id}?accept=${mimetype}`
				);
				return rsp.blob();
			}
		}
		API.rootObject = '0';

		class Playlist {
			constructor( audio, video, tracklist ) {
				this.queue = [];
				this.current = null;

				this.audio = audio;
				this.video = video;
				this.tracklist = tracklist;

				this.audio.addEventListener( 'ended', e => {
					this.playNext();
				} );
				this.video.addEventListener( 'ended', e => {
					this.playNext();
				} );
			}

			enqueue( item ) {
				if ( ! [ 'object.item.audioItem', 'object.item.videoItem' ].some( k => item.itemClass.startsWith( k ) ) ) {
					throw `invalid playlist item: directory ${item.directory}, id ${item.id}, class ${item.itemClass}`;
				}

				this.queue.push( item );
				this.tracklist.appendChild( _li( item.title,
					_button( '▶️', { click: () => this.skip( item ) } ),
					_button( '🚮', { click: e => { this.dequeue( item ); e.target.parentElement.parentElement.removeChild( e.target.parentElement ); } } ),
				) );

				if ( ! this.current ) {
					this.playNext();
				}
			}

			dequeue( item ) {
				if ( item === this.current ) {
					// TODO: throw?
					return;
				}
				this.queue = this.queue.filter( i => i !== item );
			}

			skip( item ) {
				this.current = item;
				this.play();
			}

			playNext() {
				if ( ! this.queue ) {
					// empty playlist.
					return;
				}

				if ( ! this.current ) {
					// start playing.
					this.current = this.queue[ 0 ];
					this.play();
					return;
				}

				const index = this.queue.indexOf( this.current );

				if ( index < 0 ) {
					throw `item not in playlist`;
				}

				if ( index === ( this.queue.length - 1 ) ) {
					// playlist ended.
					return;
				}

				this.current = this.queue[ index + 1 ];
				this.play();
			}

			play() {
				// TODO: extract the proper mimetype.
				const [ enabled, disabled, mimetype ] =
					this.current.itemClass.startsWith( 'object.item.audioItem' ) ?
						[ this.audio, this.video, 'audio/*' ] : [ this.video, this.audio, 'video/*' ];
				enabled.src = `/directories/${this.current.directory}/${this.current.id}?accept=${mimetype}`;
				enabled.play();
			}
		}


		const main = document.querySelector( 'main' );
		const audio = document.querySelector( '#player audio' );
		const video = document.querySelector( '#player video' );
		const tracklist = document.querySelector( '#player ul' );

		const api = new API();
		const playlist = new Playlist( audio, video, tracklist );

		const newObject =
			( parentID, o ) => (
				o.itemClass.startsWith( 'object.container' )      ? newContainer :
				o.itemClass.startsWith( 'object.item.audioItem' ) ? newAudio     :
				o.itemClass.startsWith( 'object.item.videoItem' ) ? newVideo     :
				                                                    newNothing   )( parentID, o );

		const newContainer =
			( udn, o ) => _li(
				_input( {
					'data-id': o.id,
					'data-udn': udn,
					id: `${udn}/${o.id}`,
					type: 'checkbox',
					change: e => {
						if ( e.target.checked ) {
							api.object( udn, e.target.dataset.id )
							   .then( o => e.target.parentElement.appendChild(
								_ul( o.children.map( c => newObject( udn, c ) ) ) )
							   )
							   .catch( console.error );
						} else {
							const ul = e.target.parentElement.querySelector( 'ul' );
							e.target.parentElement.removeChild( ul );
						}
					},
				} ),
				_label( o.title, { for: `${udn}/${o.id}` } ),
			);

		const newAudio =
			( udn, o ) => _li(
				_button( o.title, {
					'data-id': o.id,
					'data-udn': udn,
					'click': e => playlist.enqueue( o ),
					disabled: ! o.mimetypes.some( m => audio.canPlayType( m ) ),
				} ),
			);

		const newVideo =
			( udn, o ) => _li(
				_button( o.title, {
					'data-id': o.id,
					'data-udn': udn,
					'click': e => playlist.enqueue( o ),
					disabled: ! o.mimetypes.some( m => video.canPlayType( m ) ),
				} ),
			);

		const newNothing =
			( udn, o ) => _li( _button( o.title, { disabled: true } ) );

		const newDirectory =
			d => _li(
				_input( {
					'data-udn': d.udn,
					id: d.udn,
					type: 'checkbox',
					change: e => {
						if ( e.target.checked ) {
							const udn = e.target.dataset.udn;
							api.object( udn, API.rootObject )
							   .then( o => e.target.parentElement.appendChild(
								  _ul( newObject( d.udn, o ) ) )
							   )
							   .catch( console.error );
						} else {
							const ul = e.target.parentElement.querySelector( 'ul' );
							e.target.parentElement.removeChild( ul );
						}
					},
				} ),
				_label( d.name, { for: d.udn } ),
			);

		api.directories()
		   .then( ds => _ul( ds.map( newDirectory ) ) )
		   .then( ul => main.appendChild( ul ) );
	</script>
</body>
</html>
